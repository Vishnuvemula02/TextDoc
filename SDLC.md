SDLC (Software Development Life Cycle)
It is a step by step procedure or a standard procedure to start a new project or to develop a new software.
When does SDLC start?
  When a person or a company wants to start with a new project they have to start with SDLC.
Why we should follow SDLC? Or What will happen if you didn't follow SDLC ?
•	We will not get to know how many engineers are required to complete the project.
•	We will not get to know how much cost is required to complete the project.
•	There will be no supporting requirement documentation.
•	There will be delay in releasing software to the customer.

             
Stages of SDLC:
1.	Requirement Gathering  --> Business Analyst/Product Analyst
2.	Planning / Analysis / Feasibility Study --> Project Manager, BA, Architect, Finance Team, HR Team
3.	Design --> Architect/Sr. Architect/Technical Architect
4.	Coding --> Sr. Developer, Jr. Developer, Fresher
5.	Testing --> Sr. Test Engineer, Jr. Test Engineer, Fresher
6.	Deployment / Installation --> IT Engineer/Site Engineer/Field Engineer/Installation Engineer
7.	Maintenance 
SDLC has different Model:
•	Waterfall Model
•	Spiral Model
•	V&V Model
•	Prototype Model
•	Derived Model
•	Hybrid Model
•	Agile Model

Waterfall Model:
•	It is a step by step procedure or a standard procedure to develop a new software.
•	It is also called as traditional model or sequential model or basic model.
 

Requirement Gathering:
•	It is a gathering of the requirement from the customer place. It is done by Business Analyst or Product Analyst.
•	Business Analyst from the company will go to customer place collect requirement in Business Language (BL) & come back to company, and convert Business Language to Software Language (SL), explain it to the Project Manager (PM), Developers, Test Engineers, Architect, etc., This process is called as Requirement Collection.
•	Business Analyst will act as bridge between customer and company.






  Who can become Business Analyst?
•	Domain Expert: If a person is having around 10-15years exp in same domain & has got very good knowledge on the domain is called as Domain Expert.
•	Senior Developer: A person who is working on same project for around 8-10 years exp & has got very good knowledge on the product.
•	Senior Test Engineer: A person who is working on the same project for around 6-8 years exp & has got very good knowledge on the project.

          Note:- 
•	70-80% of critical & complex projects Business Analyst will be present.
•	20-30% of small & simple projects BA will not be present in that case Senior Developer or Senior Test Engineer will play role of Business Analyst.


Planning / Analysis / Feasibility Study: 
•	Once after Requirement gathering is done then we go for Planning / Analysis / Feasibility Study. It is done by a team which consists of Project Manager, Business Analyst, Architect, Finance Team and HR Team.
•	This is the stage where company will decide to take up the project or not & if they take up the project then company will check whether they have sufficient resources, sufficient technology & sufficient lab setup.
•	This is the stage where company will get to know that if they take up the project do they get profit or not. This process is called as Planning / Analysis / Feasibility Study.

   Role of Project Manager:
    Project Manager will interact with architect, Business Analyst, Finance team and HR team & he will decide whether to take up the project or not. Here Finance team and HR team can be optional.

 Role of Architect:
      Architect will always think from technical point of view & he will decide technically is it possible to implement the project or not. If it is possible which kind of technology should be used, this decision will be taken by architect.

  Role of Business Analyst:
       He will be involved in Requirement gathering.

  Role of Finance Team:
      Finance team will always think from money point of view & they will check what is operational cost required to work on the project & if they invest do they get profit or not.

  Role of HR:
     HR will always think from hiring resources. Resource in the sense Senior Engineers, junior engineers and freshers and here they are going to decide how many Senior Engineers, Junior engineers and fresher’s are required to complete the project.







Design:
     Once after Planning / Analysis / Feasibility Study is done then we go for Design. It is done by Architect or Sr. Architect or Technical Architect.

   There are 2 types of Design:
•	High Level Design or External Design.
•	Low Level Design or Internal Design.

High Level Design:
•	Designing the architecture of the software or project is called as High Level design.
                       
•	If there are 1 web server, 1 app server and 1 database server then it is called as 3-Tier Architecture.
•	If there are 1 web server, multiple app servers and multiple database server then it is called as N-Tier Architecture.
    If you consider any application designing main modules of an application is known as High level design.
                                           







Low Level Design:
    If you consider any application, designing each and every individual module in detail is called as Low Level Design.
      

Coding:
  Once after design is done we go for coding. It’s done by Senior Developer, junior Developer and Fresher’s by Looking in to Low Level Design Requirement. Developer implements the software according to the customer’s requirement specification. 

Testing:
   Once after Coding is done, Developers will give software to Test Engineer wherein all the Test Engineer (Senior Test engineer, junior Test engineer & Fresher) will start to test the software by entering all possible inputs into software in order to find defects in the software according to customer requirement is called as Testing.
     
Note:-
   In earlier days in waterfall model testing was done by Developer, but nowadays if you go to any company, if the company is following waterfall model, testing is done by Test engineer only.

Why developer should not involve in Testing? or What are the Disadvantages if developer involve in testing?
•	Chances are there developer may utilize all the testing time in coding.
•	Developer will be more concerned on developing the software rather than testing the software.
•	Developer will be over-confident.
•	Developer will always write the code & test it from positive point of view rather than testing from negative point of view.
•	While testing the Software if developer finds any defect, he will try to hide the defect than fixing the defect.
•	Total time taken is more.
•	Software quality will not be good.
Deployment / Installation:
       Once after Testing is done, if the software quality is good, then we go for Deployment / Installation. It is done by IT Engineer or Site Engineer or Installation Engineer. IT Engineer from the company will go to customer place, setup the environment & install the software so that customer can use the software & run the business.
 
  They are two types of Deployment / Installation:
•	Single time Installation.
•	Multiple Installations.

 Note:
•	Single time installation can be done by senior development engineer.
•	Multiple installation is done by field engineer / Installation engineer / Implementation engineer / Support Engineer. 

Maintenance:
   Once after software is installed customer will start using the software for business purpose. While using the software if the customer finds any defect, company will fix the defect without charging the customer & this may go up to 6 months or 1 year & it depends on the agreement between customer & the company. This period is called as Maintenance Period. Once after maintenance period is completed, if the customer find any defect, company will fix the defect by charging the customer.

Who will be involved in maintenance?
   The same developer & test engineer who will have built & tested the product will be involved in maintenance but the team size will be small, because the amount of work done will be less, i.e., here they might add/modify/remove the features requested by the customer & also they might fix the defect found by the customer.


Why the model is called as Waterfall Model?
     Here backtracking is not possible, i.e., once after feasibility study is completed, requirements will freeze, we cannot go back & changes the requirement, so the model is called as waterfall model.


Why will they freeze requirement in waterfall model?
     When the requirement changes, corresponding design changes, lot of defects will be introduced in the design, when the design changes, code changes, lot of defects will be introduced in the code & because of this while testing the software no. of defects which we are going to catch will be more. To avoid this they will freeze requirement.


Why requirements keep changing? or Why customer will keep on changing the requirement?
•	Because of competition in the market.
•	As and when the business changes customer keeps on changing the requirement.
•	As and when technology changes software must be changed.


Advantages of Waterfall Model:
•	It is simple to adopt.
•	Initial investment is less.
•	We can expect a stable product at the very end because requirements are friezed in the beginning.
Disadvantages of Waterfall Model:
•	Requirement changes are not allowed.
•	It is not a flexible model.
•	Developers were involved in testing.
•	Testing is the smallest phase which is done only after coding, so if there is a defect in requirement & design it flows till the end & leads to lot of rework because requirement & design is not tested.
•	It leads to lot of rework which increases the total cost of the project.
•	Turnaround time (total time) taken to deliver the product to the customer is more.

Applications of Waterfall Model:
•	Whenever we build small or simple applications.
•	Whenever we go for short term projects.
•	Whenever we are sure that customer is not going to change the requirement.



Spiral Model:
     It is a step by step procedure or a standard procedure to develop a new software. In order to overcome the Disadvantages which was there in waterfall model we have come up with Spiral Model. We go for spiral model when there is dependency.
    







Example for dependency:
   

Example for spiral model:
•	Customer will give requirement for module 'A' in business language.
•	Business Analyst will do requirement gathering for module 'A' & in the same stage Planning / Analysis / Feasibility Study will be done.
•	Architect will do design for module 'A' (High Level Design & Low Level Design)
•	Developer will do coding for module 'A' & give software to Test Engineer & Test Engineer will start to test module 'A' while testing module 'A' if Test Engineer finds any defect then Test Engineer will communicate to developer & developer will fix the defect & give new software to Test Engineer.
•	Test Engineer will uninstall old software & install the new software & test the defect first & continue testing for module 'A'. Once after testing is completed, if the software quality is good we will release the module 'A' to the customer.
•	When customer gives the requirement for new module 'B', Business Analyst will do the requirement collection for module 'B' in the same stage Planning / Analysis / Feasibility Study will be done for module 'B'. Architect will do design for module 'B' (HLD & LLD).
•	Developer before doing the coding for module 'B' they take the old code of module 'A' & write the code for new module 'B'.
•	Since there is dependency from 'B' to 'A', developer will write the integration code for 'BA'.
•	Once coding is done developer will give the software to the Test Engineer. Test Engineer will start to test the new module 'B'. Then Test Engineer if he/she finds any defect in 'B' he will communicate the defect to the developer & developer fixes the defect & gives the new software.
•	Test Engineer will retest whether the defect is fixed in module 'B' & then Test Engineer will continue testing the module 'B'.
•	Test Engineer will test the integration between 'BA’.
•	Test Engineer will test old module 'A'.
•	If the product quality is good, they will release the modules 'A' & 'B' to the customer.


Why the model is called iterative model?
     In Every Cycle Same process is repeated so the model is called iterative model.

Why the model is called incremental model?
     In Every cycle we keep on adding new model so the model is called incremental model.

 How to handle requirement changes?
    There are two types of changes.
       1. Major Changes.
       2. Minor Changes

 

Advantages of spiral model:
•	Requirement changes are allowed after each and every cycle.
•	Testing is done in each and every cycle before going to next cycle.
•	Software quality will be good.
•	It is a Controlled Model (here we take 1 module, develop the module, test the module, and make sure that the quality is good, then only we take requirement for next module).

Disadvantages of spiral model:
•	Every cycle is similar to waterfall model.
•	 Requirement & design is not tested.
•	Requirement changes are not allowed in between the cycle.

Applications of spiral model:
•	Whenever there is a dependency between the modules.
•	Whenever the requirements are given in stages.



V & V Model [Verification and Validation]:
  It is a step by step procedure or a standard procedure to develop a new software. Here each and every stage is tested.
             

Why we go for V and V model?
  To overcome the Disadvantages which were there in both waterfall model & spiral model we have come up with V&V Model, i.e., in waterfall model requirement changes was not allowed & in both waterfall model and spiral model requirement & design was not tested.


Verification: 
     Verifying or testing CRS, SRS, HLD, LLD & check whether it is working according to customer requirement or not is called as Verification. It is done by Test Engineer & it is done before software development.
It is also called as Static Testing. Here we ensure that are we building product right.

Validation: 
Testing the functionality of an application or Software by executing test cases is called as Validation. It is done by Test Engineer & it is done after Software development. It is also called as Dynamic Testing. Here we ensure that are we building right product.


V and V model diagram:
 

Explanation of V&V Model:
•	Customer will give requirement in the form of Customer requirement Specification, which will be in Business Language.
•	Business Analyst will go to the customer place, collect Customer requirement Specification & explain it to Project Manger in Business Language.
•	Project Manger will take up the Customer requirement Specification & give it to both developer & T Engineer.
•	Test Engineer will review Customer requirement Specification, write Acceptance Test Plan & Test Case, parallelly developer will be converting Customer requirement Specification to Software requirement Specification. While reviewing Customer requirement Specification if Test Engineer finds any defect(conflicting requirement, missing requirement, wrong requirement) he/she will communicate defect to the developer. Developer will cross check & confirms the defect & developer will communicate to customer. Customer will update the Customer requirement Specification & send updated Customer requirement Specification to both developer & Test Engineer. Test Engineer will review updated Customer requirement Specification & also update corresponding Test Plan & Test Case, parallelly developer will update defect in Software requirement Specification & continue converting Customer requirement Specification to Software requirement Specification. Once after it is done Software Customer requirement Specification will be ready.
•	Project Manager will take up Software requirement Specification & send it to both developer & Test Engineer. Test Engineer will review Software requirement Specification based on Customer requirement Specification & also write System Test Plan & Test case, parallelly developer will be converting Software requirement Specification to High Level Design. Once both developer & Test Engineer complete the work High Level Design will be ready.
•	Like this flow continues till coding. Once after coding is completed developer will start testing each & every line of the code, nothing but they do WBT or Unit Testing. While doing WBT if developer finds any defect in the code he will fix the defect and WBT again. After WBT developer will give Software to Test Engineer. Test Engineer will start with Validation activities, wherein first Test Engineer will do Functionality Testing by executing Functional Test Case, by doing this if Test Engineer finds any defect he will communicate the defect to the developer & developer will fix the defect perform WBT & give new Software to Test Engineer. Test Engineer will uninstall the old Software & install the new Software test the defect & continue doing Functionality Testing. After doing Functionality Testing Test Engineer will do Integration Testing, System Testing by executing corresponding Test Cases.
•	Once after System Testing is completed, Test Engineer or end users or customer will do Acceptance Testing, Once Acceptance testing is complete if Software quality is good and they will release the software to customer wherein customer use the Software& run the business.

Review CRS: 
   When We Review CRS we might find defect like.
•	Conflicting Requirements
•	Missing Requirement
•	Wrong Requirement

Advantages of V&V Model:
•	Testing starts in the early stage of project development i.e., from requirement collection stage itself.
•	All the stages are tested here because of this it avoids downward flow of defects.
•	Requirement changes are allowed.
•	The output is given simultaneously, because of this project gets completed very fast.

Disadvantages of V&V Model:
•	Initial investment is high.
•	Documentation will be more (in every stage we are writing test plan & test case).
•	Managing the interaction between developer & TE is difficult.



Applications of V&V Model:
•	Whenever we go for long term projects.
•	Whenever we build complex applications or large applications.
•	Whenever customer is expecting high quality product within short span of time.














Prototype Model:
  
 



Why we go for Prototype model:
   According to above example customer will reject the software because of miscommunication. In order to overcome this Kind of Problem Company should go for prototype model.


Prototype Model: 
    It’s is dummy model prepared by web designer or content developer where they convert text format to image format by using tool like Adobe Photoshop or Ms Paint, Picasa or Web HTML.

   
•	Customer will give requirement (60-70%). team will do feasibility study.
•	Web designers/content developers they will design and develop prototype and give it to TE. TE will start testing that prototype, while testing prototype if they find any defect (some of the text format might not be converted to image format) communicate to developer and developer will fix the defect in prototype and again send it to TE and TE will do prototype testing if there are no defects then prototype will be sent for customer review.
•	If customer is happy with the prototype then he will approve it. After approving now the architects will do design(HLD and LLD) developer will do actual coding and give Software to TE. TE will do actual testing if there are no defects and the Software quality is good then Software will be released to customer so that customer can use the Software and run the business.

What is the difference between Prototype Testing & Actual Testing?
•	Prototype Testing: 
       It is the testing done to check whether customer given requirement is present in prototype or dummy page is called Prototype Testing.
                                           (or)
It is the testing done to check whether all the text format is converted to image format is called as Prototype Testing.

•	Actual Testing:
   Testing the functionality of an application by entering all possible inputs into
the Software to find defects in the Software according to customer requirement is called as Actual Testing.

Advantages of Prototype Model:
•	There will be improved communication between customer, development & testing team.
•	Initially itself customer will get to know what the outcome of the product is.
•	Initially itself developer will get to know what exactly they have to develop.
•	Customer can request for changes in the beginning itself i.e., requirement changes are allowed & also easy to handle it.
•	We can set high expectation for the customer.
Disadvantages of Prototype Model:
•	Actual development of the application or Software starts very late because they will be busy in designing & developing prototype.
•	There is investment needed just to build the prototype.

Applications of Prototype Model:
•	When customer is new to software business.
•	When customer is not aware of full requirements.
•	When developer is new to the domain.



Derived Model or Customized Model: 
    Here we take basic model or we take single model & we change the model as per as customer requirement and company standards, that changed model is called Customized model or Derived model.
     



Hybrid Model:
   The Process of Merging or combining more than 1 in to a single model is called as Hybrid Model.
             
           


                                                         AGILE METHODOLOGY
AGILE Definition:
       It is a standard procedure or step by step procedure to develop the new software. It is an iterative & incremental approach.

AGILE Principles:
•	The main goal of agile is customer satisfaction by quick delivery of working software.
•	Customer can change the requirements at any point of development stage.
•	Release should be short
•	There will be good communication between customer, BA, developer & test engineer
•	Developer & test engineer will be doing lot of meetings at regular intervals in order to improve the quality of process

AGILE Testing: 
Testing the software by following the principle of agile methodology is called agile testing.
      
 
 Types of agile methodology:
1.	Scrum methodology
2.	Extreme programming (XP)
3.	feature driven development (FDD)
4.	lean and kanban
5.	Crystal clear
6.	Adoptive software development method (ASDM)
7.	Dynamic software development method (DSDM)



SCRUM Methodology:
     Note: mainly used in industry from 95% to 98%
RELEASE:
•	It is a combination of one or more sprint
•	1 Release = 1 Sprint = 1 Week / 2 Weeks/ 3 Weeks/ 4 Weeks
 
EPIC:
•	A requirement that is just too big to deliver in as single sprint. epics need to be broken into smaller deliverables (stories) or we can also defined as complete set of requirements is called epic.
•	One epic consist of multiple stories.

USER STORIES / STORIES/ STORY CARD:
•	A requirement that the business wants. It is something that is deliverable within a single sprint.
•	It can be a feature or modules or functionalities.

STORY POINT:
         It is rough estimation given developer and test engineer to develop & test individual stories 
           Ex:   1 story point = 9 hours
                  1 story point = 6 hours 
                    1 story point = 8 hours
Story point should be in Fibonacci series.

         STORY POINTS ESTIMATED BASES ON THE FOLLOWING ASPECTS:
•	Time spent on understanding story
•	Write test scenarios
•	Write test cases
•	Review test cases
•	Test case execution
•	Defect tracking 





         DEVELOPER STORY POINTS ESTIMATED BASED ON THE FOLLOWING ASPECTS:
•	Understanding requirements
•	Design
•	Coding
•	Reviewing code
•	WBT 
•	Time spent on fixing the defect

TASK:
        A task is a specific piece of work that needs to be completed as part of a Product Backlog item or a User Story. It represents a single unit of work that is small enough to be completed within a Sprint.

SUB-TASK:
         A sub-task is a smaller, more detailed piece of work that further breaks down a task. Sub-tasks help track the progress of a larger task and can be worked on by different people if needed.
SPRINT:
    Sprint is the actual time spent by developers and test engineer to develop and test one or more stories.

SPRINT PLANNING:
•	It is an event in scrum that defines what can be delivered in the upcoming sprint and how that work will be achieved
•	Sprint planning is a meeting conducted by scrum master on the first day every sprint
•	Explain the requirement
•	Identify list of tasks to be done
•	Assign task to engineer

SPRINT BACKLOG:
         Set of stories mapped for the sprint is called sprint backlog.
PRODUCT OWNER:
          The Product Owner is a key role responsible for ensuring that the development team works on the right tasks that deliver value to the business. The Product Owner represents the stakeholders and the customers, and their main duties include:
•	Defining the Product Backlog
•	Prioritization
•	Clarifying Requirements
•	Stakeholder Communication
•	Acceptance Criteria and Acceptance Testing
•	Maximizing Value delivered by the team.

SCRUM MASTER:
•	It is a person who is responsible for delivery of the software to the customer within a planned period of time.
•	Scrum master will track all the activities done by developer, test engineer & business analyst.
•	Business analyst / Senior test engineer / senior developer / project manager and even customer can become scrum master
 SCRUM MEETING:
•	It is a meeting conducted by a scrum master on the daily basis
•	It is also called as daily stand up meeting
•	This meeting is strictly bounded for 15 min
•	In this meeting we discuss below mentioned points
•	What you did yesterday
•	What you have planned today
•	Are there any obstacles or impediments
         NOTE: During a sprint, the team checks in during the daily scrum or standup, about how the work is progressing. The goal of this meeting is to surface any blockers and challenges that would impact the teams ability to deliver the sprint goal.

SPRINT REVIEW MEETING:
         After a sprint the team demonstrates what they have completed during the sprint review. This is your team’s opportunity to showcase their work to stake holders and team mates before it hits production

SPRINT RETROSPECTIVE MEETING:
•	It is a meeting conducted by scrum master on the last day
•	In this meeting we discuss the following points 
•	What went well
•	What didn’t go well
•	Are there any action plans


RELEASE RETROSPECTIVE MEETING SIMILAR TO SPRINT RETROSPECTIVE MEETING:
•	Product Backlog Meeting / Backlog Grooming / Backlog Refinement week before the release
•	In this meeting test engineer and developer come up which list all the pending stories which are not implemented as part of the current & previous release
•	As a team we will re prioritize all the stories from all the business point of view and more than the stories to the next upcoming sprint of releases

BUG TRIAGE MEETING:
•	This is the meeting conducted by the test engineer or scrum master, a week or 2 weeks before the release 
•	Business Analyst, Test Engineer, Developer and Scrum Master will be a part of meeting.
•	In this meeting test engineer list all the open & pending bugs which are not fixed by the developers in the current & previous release as a team we will re prioritize the defect from the customers, business point of view and decide how many bugs should be fixed as part of a current release and how many bugs can be move the upcoming release.








PRODUCT BACKLOG:
      The Product Backlog is a prioritized list of all the work or features that are required to develop and maintain the product. It is owned by the Product Owner and represents the "single source of truth" for everything the team needs to work on.

PRODUCT BACKLOG MEETING/BACKLOG GROOMING/BACKLOG REFINEMENT:
•	This is a meeting conducted by a BA or SM a week or 2 week before the release.
•	In this meeting test engineer and developer come up with lists all the pending stories which are not implemented as part of the current and previous release.
•	As a team we will re-Prioritize all the stories from the business point of view and move the stories to the next upcoming sprint or releases.

Advantages of Agile:
•	We can save time and cost of the project.
•	The quality can be ensured because each and every sprint will be tested multiple times.
•	The requirement changes can be handled.
•	All are participating in scrum so that transparency can be maintained.
•	Each and every sprint we are delivering to the client , so we can maintain the customer’s satisfaction and we can avoid delivery risk of the project.

Disadvantages of Agile:
•	It is not useful for small development projects.
•	There is a lack of intensity on necessary designing and documentation.
•	It requires an expert project member to take crucial decisions in the meeting.
•	Cost of Agile development methodology is slightly more as compared to other development methodology.
•	The project can quickly go out off track if the project manager is not clear about requirements and what outcome he/she wants.

